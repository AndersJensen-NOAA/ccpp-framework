%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{CCPP Training Documentation}
\date{May 09, 2019}
\release{v1.0}
\author{ }
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\phantomsection\label{\detokenize{Introduction:introduction}}

\chapter{Introduction}
\label{\detokenize{Introduction:id1}}\label{\detokenize{Introduction::doc}}
This document contains training material for the Common Community Physics Package (CCPP). It decsribes the:
\begin{itemize}
\item {} 
CCPP overview

\item {} 
physics schemes and interstitials

\item {} 
suite definition files

\item {} 
CCPP-compliant parameterizations

\item {} 
adding a new scheme/suite

\item {} 
host-side coding

\item {} 
fundamentals of obtaining, pre-building, building and running the CCPP with NEMSfv3gfs

\item {} 
CCPP code management and governance

\end{itemize}

For the latest version of the released code, please visit the \sphinxhref{http://www.dtcenter.org/gmtb/users/ccpp}{GMTB Website}

Please send questions and comments to the help desk: \sphinxtitleref{gmtb-help@ucar.edu}


\section{How To Use This Document}
\label{\detokenize{Introduction:how-to-use-this-document}}
This table describes the type changes and symbols used in this guide.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Typeface or Symbol}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Meaning}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Example}
\\
\hline
\sphinxcode{\sphinxupquote{AaBbCc123}}
&
The names of commands,
files, and directories; 
on-screen computer output
&
Edit your \sphinxcode{\sphinxupquote{.bashrc}} 
Use \sphinxcode{\sphinxupquote{ls -a}} to list all files. 
\sphinxcode{\sphinxupquote{host\$ You have mail!}}
\\
\hline
\sphinxcode{\sphinxupquote{AaBbCc123}}
&
What you type contrasted
with on-screen computer
output
&
\sphinxcode{\sphinxupquote{host\$}} \sphinxcode{\sphinxupquote{su}}
\\
\hline
\sphinxcode{\sphinxupquote{\%}}
&
Command-line prompt
&
\sphinxcode{\sphinxupquote{\% cd \$TOP\_DIR}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Following these typefaces and conventions, shell commands, code examples, namelist variables, etc.
will be presented in this style:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZpc{}} mkdir \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{TOP\PYGZus{}DIR}\PYG{l+s+si}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{CCPP Overview}
\label{\detokenize{Overview:ccpp-overview}}\label{\detokenize{Overview:overview}}\label{\detokenize{Overview::doc}}
Ideas for this project originated within the Earth System Prediction Capability (ESPC)
Physics Interoperability group, which has representatives from NCAR, the Navy, NOAA
Research, NOAA National Weather Service, and other groups. Physics Interoperability,
or the ability to run a given physics suite in various host models, has been a goal
of this multi-agency group for several years. An initial mechanism to run the physics
of NOAA’s Global Forecast System (GFS) model in other host models was developed by
the NOAA Environmental Modeling Center (EMC) and later augmented by NOAA GFDL.  The
CCPP expanded on that work by meeting additional requirements put forth by
\sphinxhref{https://dtcenter.org/gmtb/users/ccpp/developers/requirements/CCPP\_REQUIREMENTS.pdf}{NOAA},
and brought new functionalities to the physics-dynamics interface. Those include
the ability to choose the order of parameterizations, to subcycle individual
parameterizations by running them more frequently than other parameterizations,
and to group arbitrary sets of parameterizations allowing other computations in
between them (e.g., dynamics and coupling computations).

The architecture of the CCPP and its connection to a host model is shown in
\hyperref[\detokenize{Overview:ccpp-arch-host}]{Figure \ref{\detokenize{Overview:ccpp-arch-host}}}.
There are two distinct parts to the CCPP: a library of physical parameterizations
that conforms to selected standards (\sphinxstyleemphasis{CCPP-Physics}) and an infrastructure (\sphinxstyleemphasis{CCPP-Framework})
that enables connecting the physics to host models.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{ccpp_arch_host}.png}
\caption{\sphinxstyleemphasis{Architecture of the CCPP and its connection with a host model,
here represented as the driver for an atmospheric model (yellow box). The dynamical
core (dycore), the physics, and other aspects of the model (such as coupling) are
connected to the driving host through the pool of physics caps. The CCPP-Physics is
denoted by the gray box at the bottom of the physics, and encompasses the
parameterizations, which are accompanied by parameterization caps.}}\label{\detokenize{Overview:id1}}\label{\detokenize{Overview:ccpp-arch-host}}\end{figure}

The host model also needs to have functional documentation for any variable that will be
passed to, or received from, the physics. The CCPP-Framework is used to compare the variables
requested by each physical parameterization against those provided by the host model, and
check whether they are available (otherwise an error is issued).  This process has greatly
served to expose the variables passed between physics and dynamics, and also to clarify
how suites exchange information among parameterizations. During runtime, the CCPP-Framework
is responsible for communicating the necessary variables between the host model and the
parameterizations.

Building the CCPP involves a \sphinxstyleemphasis{prebuild} step, and an actual build step. As of this
writing, the CCPP has been connected with the GMTB Single Column Model (SCM)
and with various configurations of NOAA’s Unified
Forecast System (UFS). As described in detail later in this document, there are
multiple modes of building the CCPP along with the UFS, and the user should choose the
mode that best matches their needs. With the CCPP dynamic build, all CCPP-compliant
parameterizations are compiled into a library which is linked to the host model at
runtime. Conversely, with the CCPP static build, a single suite is compiled into a
library and linked to the host model when it is compiled. The dynamic build favors
flexibility, as users can choose the parameterizations and their order at runtime,
while the static build favors performance, as it provides superior execution time and
a smaller memory footprint. The type of build defines several differences in the
creation and use of the auto-generated code, many of which are not exposed to the user.
The differences pertain to  the interfaces between CCPP-Framework and the physics
(physics \sphinxstyleemphasis{caps}) and the host model (host model \sphinxstyleemphasis{cap}), as well as in the procedures
for calling the physics. When the CCPP is used with the SCM, the dynamic build is used.

The CCPP Physics is envisioned to contain parameterizations and suites that are used
operationally in the UFS, as well as parameterizations that are under development
for possible transition to operations in the future. By distributing and supporting
the CCPP to the scientific community, a large number of scientists can experiment
with and innovate physics.  \hyperref[\detokenize{Overview:ccpp-ecosystem}]{Figure \ref{\detokenize{Overview:ccpp-ecosystem}}} shows the CCPP ecosystem,
a significant effort in transition of research to operations that can benefit physics
developers, users, and NOAA operations.

The CCPP-Physics and its associated CCPP-Framework are developed as open source codes,
follow industry-standard code management practices, and are freely distributed through
GitHub (\sphinxurl{https://github.com/NCAR/ccpp-physics} and \sphinxurl{https://github.com/NCAR/ccpp-framework}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{ccpp_ecosystem}.png}
\caption{\sphinxstyleemphasis{CCPP ecosystem}}\label{\detokenize{Overview:id2}}\label{\detokenize{Overview:ccpp-ecosystem}}\end{figure}

The first public release of CCPP took place in April 2018 and included all parameterizations
of the operational GFS v14, along with the ability to connect to the GMTB SCM.
The second public release of the CCPP took place in August of 2018 and additionally included
the physics suite tested in advance of the GFS v15 implementation.  Since then, additional
parameterizations have been made CCPP-compliant, in order to encompass the suites that are
under consideration for GFS v16.  A summary of the suites supported in the CCPP can be found
in \hyperref[\detokenize{Overview:scheme-suite-table}]{Table \ref{\detokenize{Overview:scheme-suite-table}}}.  In addition to the schemes listed, it is expected
that, as time goes on, other parameterizations will be considered for inclusion in the CCPP.

The CCPP is governed by the groups that contribute to its development.  Governance for the
CCPP-Physics is currently led by NOAA, and the GMTB works with EMC and the NGGPS Program Office
to determine which schemes and suites should be included and supported. Governance for the
CCPP-Framework is done jointly by NOAA and NCAR, and more information can be found at
\sphinxurl{https://github.com/NCAR/ccpp-framework/wiki}. Additional information can also be found on
the GMTB website at \sphinxurl{https://dtcenter.org/gmtb/users/ccpp}. Please direct all inquiries to \sphinxhref{mailto:gmtb-help@ucar.edu}{gmtb-help@ucar.edu}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{\sphinxstyleemphasis{Schemes and suites available in the CCPP}}\label{\detokenize{Overview:id3}}\label{\detokenize{Overview:scheme-suite-table}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Schemes/Suites}
&\sphinxstyletheadfamily 
\sphinxstylestrong{GFS v14}
&\sphinxstyletheadfamily 
\sphinxstylestrong{FV3GFSv1}
&\sphinxstyletheadfamily 
\sphinxstylestrong{FV3GFS v1.1}
&\sphinxstyletheadfamily 
\sphinxstylestrong{EMC/CPT}
&\sphinxstyletheadfamily 
\sphinxstylestrong{GSD}
\\
\hline
Microphysics
&
Zhao-Carr
&
GFDL
&
GFDL
&
aaMG3
&
aaThompson
\\
\hline
PBL
&
EDMF
&
EDMF
&
TKE EDMF
&
EDMF
&
MYNN
\\
\hline
Deep cu
&
saSAS
&
saSAS
&
saSAS
&
CSAW
&
GF
\\
\hline
Shallow cu
&
saSAS
&
saSAS
&
saSAS
&
saSAS
&
MYNN
\\
\hline
Radiation
&
RRTMG
&
RRTMG
&
RRTMG
&
RRTMG
&
RRTMG
\\
\hline
Surface Layer
&
GFS
&
GFS
&
GFS
&
GFS
&
GFS
\\
\hline
Land surface
&
Noah
&
Noah
&
Noah
&
Noah
&
RUC
\\
\hline
Ozone
&
NRL 2006
&
NRL 2015
&
NRL 2015
&
NRL 2015
&
NRL 2015
\\
\hline
H2O
&
None
&
NRL 2015
&
NRL 2015
&
NRL 2015
&
NRL 2015
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstyleemphasis{The first row lists the suites currently available in the CCPP. The first column
denotes the types of parameterizations, where cu stands for convective parameterization and H2O for
stratospheric water vapor. The operational GFS V14 suite (column 1) used Zhao-Carr microphysics,
Eddy-Diffusivity Mass Flux (EDMF) PBL, scale-aware Simplified Arakawa Schubert (saSAS) convection,
Rapid Radiation Transfer Model for General Circulation Models (RRTMG) radiation, GFS surface layer,
Noah LSM, Navy Research Laboratory (NRL) ozone, and no stratospheric water vapor scheme.  The FV3GFS
v1 suite, uses the GFDL microphysics and the NRL 2015 ozone and photolysis schemes. The other three
suites are candidates for future operational implementations. The FV3GFS v1.1 suite uses Turbulent
Kinetic Energy (TKE)-based EDMF, the EMC and Climate Process Team (CPT) suite uses the scale-aware
(aa) Morrison-Gettelman 3 (MG3) microphysics and Chikira-Sugiyama convection with Arakawa-Wu extension
(CSAW) deep convection, and the NOAA Global Systems Division (GSD) suite uses aerosol aware
Thompson microphysics, Mellor-Yamada-Nakashini-Niino (MYNN) PBL and shallow convection, and
Rapid Update Cycle (RUC) LSM.}


\chapter{CCPP-Compliant Physics Parameterizations}
\label{\detokenize{CompliantPhysicsParams:ccpp-compliant-physics-parameterizations}}\label{\detokenize{CompliantPhysicsParams:compliantphysparams}}\label{\detokenize{CompliantPhysicsParams::doc}}
A basic description of the rules for a parameterization to be considered CCPP-compliant
is summarized in this section (see also \sphinxcite{CompliantPhysicsParams:heinzelleretal2018}).

It should be noted that making a scheme CCPP-compliant is a necessary step for acceptance of the
scheme in the pool of supported CCPP physics schemes, but does not guarantee it. Acceptance is subject to
approval by a Governance committee and depends on scientific innovation, demonstrated added
value, and compliance with the rules described below. The criteria for acceptance of innovations into the
CCPP is under development. For further information, please contact the GMTB helpdesk at \sphinxhref{mailto:gmtb-help@ucar.edu}{gmtb-help@ucar.edu}.

It is recommended that parameterizations be comprised of the smallest units that will be used.
For example, if a given set of deep and shallow convection schemes will always be called together
and in a pre-established order, it is acceptable to group them within a single scheme. However, if one
envisions that the deep and shallow convection schemes may someday operate independently, they should
be coded as two separate schemes to allow for more flexibility.

Some schemes in the CCPP have been implemented using a driver as an entry point. In this context,
a driver is defined as a wrapper that sits on top of the actual scheme and provides the CCPP entry
points. In order to minimize the layers of code in the CCPP, the implementation of a driver is
discouraged, that is, it is preferable that the CCPP be composed of atomic parameterizations. One
example is the implementation of the Morrison-Gettelman microphysics, in which a simple entrypoint
leads to two versions of the scheme, MG2 and MG3.  A cleaner implementation would be to retire MG2
in favor of MG3, to put MG2 and MG3 as separate schemes, or to create a single scheme that can behave
as MG2 nd MG3 depending on namelist options.

However, there are some reasons that may justify the implementation of a driver:
\begin{itemize}
\item {} 
To preserve schemes that are also distributed outside of the CCPP. For example, the Thompson
microphysics scheme is distributed both with the WRF model and with the CCPP. Having a driver
with CCPP directives allows the Thompson scheme to remain intact so that it can be synchronized
between the WRF and CCPP distributions.

\item {} 
To deal with optional arguments.

\item {} 
To perform unit conversions and array transformations, such as flip the vertical direction
and rearrange index order. Note that, in the future, these capabilities will be included
in the CCPP-Framework so that schemes do not have to perform these operations.

\end{itemize}

Somewhere here include info on schemes that have options, such as MG2 and MG3 are in the same
scheme.  MYNN has many options.  So does GF.  It is a grey area what is defined as a new scheme
versus options within a scheme.


\section{General rules}
\label{\detokenize{CompliantPhysicsParams:general-rules}}
{\hyperref[\detokenize{CompliantPhysicsParams:scheme-template}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 1}}}} contains a Fortran template for a CCPP-compliant scheme, which can also
be found in \sphinxcode{\sphinxupquote{ccpp/framework/doc/DevelopersGuide/scheme\_template.F90}}.

\def\sphinxLiteralBlockLabel{\label{\detokenize{CompliantPhysicsParams:scheme-template}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{module }\PYG{n}{scheme\PYGZus{}template}

      \PYG{k}{contains}

\PYG{k}{      }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}init} \PYG{p}{(}\PYG{p}{)}
      \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}init}

      \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
      \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}finalize}

\PYG{c}{!\PYGZgt{} \PYGZbs{}section arg\PYGZus{}table\PYGZus{}scheme\PYGZus{}template\PYGZus{}run Argument Table}
\PYG{c}{!! \textbar{} local\PYGZus{}name \textbar{} standard\PYGZus{}name      \textbar{} long\PYGZus{}name                                \textbar{} units \textbar{} rank \textbar{} type      \textbar{} kind  \textbar{} intent \textbar{} optional \textbar{}}
\PYG{c}{!! \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}}
\PYG{c}{!! \textbar{} errmsg     \textbar{} ccpp\PYGZus{}error\PYGZus{}message \textbar{} error message for error handling in CCPP \textbar{} none  \textbar{}    0 \textbar{} character \textbar{} len=* \textbar{} out    \textbar{} F        \textbar{}}
\PYG{c}{!! \textbar{} errflg     \textbar{} ccpp\PYGZus{}error\PYGZus{}flag    \textbar{} error flag for error handling in CCPP    \textbar{} flag  \textbar{}    0 \textbar{} integer   \textbar{}       \textbar{} out    \textbar{} F        \textbar{}}
\PYG{c}{!!}
      \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}run} \PYG{p}{(}\PYG{n}{errmsg}\PYG{p}{,} \PYG{n}{errflg}\PYG{p}{)}

         \PYG{k}{implicit }\PYG{k}{none}

         \PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{} arguments}
         \PYG{c}{! add your arguments here}
         \PYG{k+kt}{character}\PYG{p}{(}\PYG{n+nb}{len}\PYG{o}{=}\PYG{o}{*}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}   \PYG{k+kd}{::} \PYG{n}{errmsg}
         \PYG{k+kt}{integer}\PYG{p}{,}          \PYG{k}{intent}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}   \PYG{k+kd}{::} \PYG{n}{errflg}

         \PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{} local variables}
         \PYG{c}{! add your local variables here}

         \PYG{k}{continue}

         \PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{} initialize CCPP error handling variables}
         \PYG{n}{errmsg} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
         \PYG{n}{errflg} \PYG{o}{=} \PYG{l+m+mi}{0}

         \PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{} initialize intent(out) variables}
         \PYG{c}{! initialize all intent(out) variables here}

         \PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{} actual code}
         \PYG{c}{! add your code here}

         \PYG{c}{! in case of errors, set errflg to a value != 0,}
         \PYG{c}{! assign a meaningful message to errmsg and return}

         \PYG{k}{return}

\PYG{k}{      }\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}template\PYGZus{}run}

    \PYG{k}{end }\PYG{k}{module }\PYG{n}{scheme\PYGZus{}template}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Each scheme must be in its own module (module name = scheme name) and must have three entry
points (subroutines) starting with the name of the module:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{module }\PYG{n}{scheme}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{private}
\PYG{k}{  }\PYG{k}{public} \PYG{k+kd}{::} \PYG{n}{scheme\PYGZus{}init}\PYG{p}{,}\PYG{n}{scheme\PYGZus{}run}\PYG{p}{,}\PYG{n}{scheme\PYGZus{}finalize}
  \PYG{k}{contains}
\PYG{k}{    }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}init}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}finalize}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}run}
\PYG{k}{end }\PYG{k}{module }\PYG{n}{scheme}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\_init}} and \sphinxcode{\sphinxupquote{\_finalize}} routines are run automatically when the CCPP physics are initialized and
finalized, respectively.  These routines may be called more than once, depending on the host model’s
parallelization strategy, and as such must be idempotent (that is, the answer must be the same when
the subroutine is called multiple times).
\begin{itemize}
\item {} 
Additional modules (\sphinxcode{\sphinxupquote{scheme\_pre}} and \sphinxcode{\sphinxupquote{scheme\_post}}) can be used if there is any part of the physics
scheme that must be executed before or after the \sphinxcode{\sphinxupquote{module scheme}} defined above.  These situations are
described in more detail in Section 5.2 and 6.1.2. If additional modules are included, they also
must have three entry points:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{module }\PYG{n}{scheme\PYGZus{}pre}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{private}
\PYG{k}{  }\PYG{k}{public} \PYG{k+kd}{::} \PYG{n}{scheme\PYGZus{}pre\PYGZus{}init}\PYG{p}{,} \PYG{n}{scheme\PYGZus{}pre\PYGZus{}run}\PYG{p}{,} \PYG{p}{\PYGZam{}}
            \PYG{n}{scheme\PYGZus{}pre\PYGZus{}finalize}
  \PYG{k}{contains}
\PYG{k}{    }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}init}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}finalize}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}pre\PYGZus{}run}
\PYG{k}{end }\PYG{k}{module }\PYG{n}{scheme\PYGZus{}pre}

\PYG{k}{module }\PYG{n}{scheme\PYGZus{}post}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{private}
\PYG{k}{  }\PYG{k}{public} \PYG{k+kd}{::} \PYG{n}{scheme\PYGZus{}post\PYGZus{}init}\PYG{p}{,} \PYG{n}{scheme\PYGZus{}post\PYGZus{}run}\PYG{p}{,} \PYG{p}{\PYGZam{}}
            \PYG{n}{scheme\PYGZus{}post\PYGZus{}finalize}
  \PYG{k}{contains}
\PYG{k}{    }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}init}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}finalize}
    \PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{scheme\PYGZus{}post\PYGZus{}run}
\PYG{k}{end }\PYG{k}{module }\PYG{n}{scheme\PYGZus{}post}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
All CCPP entrypoint schemes need to be accompanied by a table that describes the arguments to
the subroutine (see example in {\hyperref[\detokenize{CompliantPhysicsParams:scheme-template}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 1}}}}).  However, empty schemes
(e.g., \sphinxcode{\sphinxupquote{scheme\_template\_init}} in {\hyperref[\detokenize{CompliantPhysicsParams:scheme-template}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 1}}}}) are excepted and need
no argument table.

\item {} 
The order of arguments in the table does not need to be the same as in the argument list of
the subroutine, but that is preferable.

\item {} 
The argument table must precede the entry point subroutine, and must start with
\sphinxcode{\sphinxupquote{!\textgreater{} \textbackslash{}section arg\_table\_subroutine\_name Argument Table}} and end with a line containing only \sphinxcode{\sphinxupquote{!!}}

\item {} \begin{description}
\item[{All external information required by the scheme must be passed in via the argument list.}] \leavevmode\begin{itemize}
\item {} 
Statements such as \sphinxcode{\sphinxupquote{use EXTERNAL\_MODULE}} should not be used for passing in data and
all physical constants should go through the argument list.

\end{itemize}

\end{description}

\item {} 
If the width of an argument table exceeds 250 characters, the argument table should be wrapped.
in C preprocessor directives:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}if 0}
\PYG{c}{!\PYGZgt{} \PYGZbs{}section arg\PYGZus{}table\PYGZus{}scheme\PYGZus{}template\PYGZus{}run Argument Table...}
\PYG{c}{!!}
\PYG{c+cp}{\PYGZsh{}endif}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
For better readability, it is suggested to align the columns in the metadata table.

\item {} 
Note that module names, scheme names and subroutine names are case sensitive.

\end{itemize}


\section{Input/output variable (argument) rules}
\label{\detokenize{CompliantPhysicsParams:input-output-variable-argument-rules}}\begin{itemize}
\item {} 
Variables available for CCPP physics schemes are identified by their unique
\sphinxcode{\sphinxupquote{standard\_name}}. While an effort is made to comply with existing \sphinxcode{\sphinxupquote{standard\_name}}
definitions of the CF conventions (\sphinxurl{http://cfconventions.org}), additional names
are used in the CCPP (see below for further information).

\item {} 
A list of available standard names and an example of naming conventions can be found in
\sphinxcode{\sphinxupquote{ccpp/framework/doc/DevelopersGuide/CCPP\_VARIABLES\_\$\{HOST\}.pdf}}, where \sphinxcode{\sphinxupquote{\$\{HOST\}}} is the
name of the host model.  Running the CCPP prebuild script (described in Chapter 3)
will generate a LaTeX source file that can be compiled to produce
a PDF file with all variables defined by the host model and requested by the physics schemes.

\item {} 
A \sphinxcode{\sphinxupquote{standard\_name}} cannot be assigned to more than one local variable (\sphinxcode{\sphinxupquote{local\_name}}).
The \sphinxcode{\sphinxupquote{local\_name}} of a variable can be chosen freely and does not have to match the
\sphinxcode{\sphinxupquote{local\_name}} in the host model.

\item {} 
All variable information (units, rank, index ordering) must match the specifications on
the host model side, but sub-slices can be used/added in the host model. For example, in
\sphinxcode{\sphinxupquote{GFS\_typedefs.F90}}, tendencies can be split so they can be used in the necessary physics scheme:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!! \textbar{} IPD\PYGZus{}Data(nb)\PYGZpc{}Intdiag\PYGZpc{}dt3dt(:,:,1) \textbar{} cumulative\PYGZus{}change\PYGZus{}in\PYGZus{}temperature\PYGZus{}due\PYGZus{}to\PYGZus{}longwave\PYGZus{}radiation}
\PYG{c}{!! \textbar{} IPD\PYGZus{}Data(nb)\PYGZpc{}Intdiag\PYGZpc{}dt3dt(:,:,2) \textbar{} cumulative\PYGZus{}change\PYGZus{}in\PYGZus{}temperature\PYGZus{}due\PYGZus{}to\PYGZus{}shortwave\PYGZus{}radiation\PYGZus{}and\PYGZus{}orographic\PYGZus{}gravity\PYGZus{}wave\PYGZus{}drag}
\PYG{c}{!! \textbar{} IPD\PYGZus{}Data(nb)\PYGZpc{}Intdiag\PYGZpc{}dt3dt(:,:,3) \textbar{} cumulative\PYGZus{}change\PYGZus{}in\PYGZus{}temperature\PYGZus{}due\PYGZus{}to\PYGZus{}PBL}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The two mandatory variables that every scheme must accept as \sphinxcode{\sphinxupquote{intent(out)}} arguments are
\sphinxcode{\sphinxupquote{errmsg}} and \sphinxcode{\sphinxupquote{errflg}} (see also coding rules).

\item {} \begin{description}
\item[{At present, only two types of variable definitions are supported by the CCPP framework:}] \leavevmode\begin{itemize}
\item {} 
Standard Intrinsic Fortran variables are preferred (\sphinxcode{\sphinxupquote{character}}, \sphinxcode{\sphinxupquote{integer}}, \sphinxcode{\sphinxupquote{logical}}, \sphinxcode{\sphinxupquote{real}}).
For character variables, the length should be specified as \sphinxcode{\sphinxupquote{\textbackslash{}∗}}. All others can have a kind attribute
of a kind type defined by the host model.

\item {} 
Derived data types (DDTs). While the use of DDTs is discouraged in general, some use cases may
justify their application (e.g. DDTs for chemistry that contain tracer arrays or information on
whether tracers are advected). It should be understood that use of DDTs within schemes
forces their use in host models and potentially limits a scheme’s generality. Where possible,
DDTs should be broken into components that could be usable for another scheme of the same type.
Where DDTs currently exist within CCPP-compliant schemes, they are likely there due to expediency
concerns and should eventually be phased out.

\end{itemize}

\end{description}

\item {} 
It is preferable to have separate variables for physically-distinct quantities. For example,
an array containing various cloud properties should be split into its individual
physically-distinct components to facilitate generality. An exception to this rule is if
there is a need to perform the same operation on an array of otherwise physically-distinct
variables. For example, tracers that undergo vertical diffusion can be combined into one array
where necessary. This tactic should be avoided wherever possible, and is not acceptable merely
as a convenience.

\item {} 
If a scheme is to make use of CCPP’s subcycling capability in the suite definition
file (SDF; see also GMTB Single Column Model Technical Guide v2.1, chapter 6.1.3,
\sphinxurl{https://dtcenter.org/gmtb/users/ccpp/docs}), the loop counter can be obtained from CCPP as
an \sphinxcode{\sphinxupquote{intent(in)}} variable (see Listings 3.1 and 3.2 for a mandatory list of variables
that are provided by the CCPP framework and/or the host model for this and other purposes).

\end{itemize}


\section{Coding rules}
\label{\detokenize{CompliantPhysicsParams:coding-rules}}\begin{itemize}
\item {} 
Code must comply to modern Fortran standards (Fortran 90/95/2003).

\item {} \begin{description}
\item[{Labeled \sphinxcode{\sphinxupquote{end}} statements should be used for modules, subroutines and functions, for example:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\$module scheme\_template \(\rightarrow\) end module scheme\_template}}

\end{itemize}

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{implicit none}} is not allowed.

\item {} 
All \sphinxcode{\sphinxupquote{intent(out)}} variables must be set inside the subroutine, including the mandatory
variables \sphinxcode{\sphinxupquote{errflg}} and \sphinxcode{\sphinxupquote{errmsg}}.

\item {} 
Decomposition-dependent host model data inside the module cannot be permanent,
i.e. variables that contain domain-dependent data cannot be kept using the \sphinxcode{\sphinxupquote{save}} attribute.

\item {} 
\sphinxcode{\sphinxupquote{goto}} statements are not alowed.

\item {} 
\sphinxcode{\sphinxupquote{common}} blocks are not allowed.

\item {} 
Errors are handled by the host model using the two mandatory arguments \sphinxcode{\sphinxupquote{errmsg}} and
\sphinxcode{\sphinxupquote{errflg}}. In the event of an error, a meaningful error message should be assigned to \sphinxcode{\sphinxupquote{errmsg}}
and set errflg to a value other than 0, for example:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
write \PYG{o}{(}errmsg, ‘\PYG{o}{(}*\PYG{o}{(}a\PYG{o}{)}\PYG{o}{)}’\PYG{o}{)} ‘Logic error in scheme xyz: …’
\PYG{n+nv}{errflg} \PYG{o}{=} \PYG{l+m}{1}
\PYG{k}{return}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Schemes are not allowed to abort/stop the program.

\item {} 
Schemes are not allowed to perform I/O operations (except for reading lookup tables
or other information needed to initialize the scheme), including stdout/stderr.

\item {} 
Line lengths of up to 120 characters are suggested for better readability (exception: CCPP
metadata argument tables).

\end{itemize}

Additional coding rules are listed under the \sphinxstyleemphasis{Coding Standards} section of the NOAA NGGPS
Overarching System team document on Code, Data, and Documentation Management for NEMS
Modeling Applications and Suites (available at
\sphinxurl{https://docs.google.com/document/u/1/d/1bjnyJpJ7T3XeW3zCnhRLTL5a3m4\_3XIAUeThUPWD9Tg/edit\#heading=h.97v79689onyd}).


\section{Parallel programming rules}
\label{\detokenize{CompliantPhysicsParams:parallel-programming-rules}}
Most often shared memory (OpenMP) and MPI communication are done outside the physics in
which case the physics looping and arrays already take into account the sizes of the
threaded tasks through their input indices and array dimensions.  The following rules
should be observed when including OpenMP or MPI communication in a physics scheme:
\begin{itemize}
\item {} 
Shared-memory (OpenMP) parallelization inside a scheme is allowed with the restriction
that the number of OpenMP threads to use is obtained from the host model as in \sphinxcode{\sphinxupquote{intent(in)}}
argument in the argument list (Listings 3.1 and 3.2).

\item {} 
MPI communication is allowed in the \sphinxcode{\sphinxupquote{\_init}} and \sphinxcode{\sphinxupquote{\_finalize}} phase for the purpose
of computing, reading or writing scheme-specific data that is independent of the host
model’s data decomposition. An example is the initial read of a lookup table of aerosol
properties by one or more MPI processes, and its subsequent broadcast to all processes.
Several restrictions apply:
\begin{itemize}
\item {} 
The implementation of reading and writing of data must be scalable to perform
efficiently from a few to millions of tasks.

\item {} 
The MPI communicator must be provided by the host model as an \sphinxcode{\sphinxupquote{intent(in)}}
argument in the argument list (Listings 3.1 and 3.2).

\item {} 
The use of MPI is restricted to global communications: \sphinxcode{\sphinxupquote{barrier}}, \sphinxcode{\sphinxupquote{broadcast}},
\sphinxcode{\sphinxupquote{gather}}, \sphinxcode{\sphinxupquote{scatter}}, \sphinxcode{\sphinxupquote{reduce}}.

\item {} 
The use of MPI\_COMM\_WORLD is not allowed.

\item {} 
The use of point-to-point communication is not allowed.

\end{itemize}

\item {} 
Calls to MPI and OpenMP functions, and the import of the MPI and OpenMP libraries,
must be guarded by C preprocessor directives as illustrated in the following listing.
OpenMP pragmas can be inserted without C preprocessor guards, since they are ignored
by the compiler if the OpenMP compiler flag is omitted.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}ifdef MPI}
  \PYG{k}{use }\PYG{n}{mpi}
\PYG{c+cp}{\PYGZsh{}endif}
\PYG{c+cp}{\PYGZsh{}ifdef OPENMP}
  \PYG{k}{use }\PYG{n}{omp\PYGZus{}lib}
\PYG{c+cp}{\PYGZsh{}endif}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}ifdef MPI}
  \PYG{k}{call }\PYG{n}{MPI\PYGZus{}BARRIER}\PYG{p}{(}\PYG{n}{mpicomm}\PYG{p}{,} \PYG{n}{ierr}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}endif}

\PYG{c+cp}{\PYGZsh{}ifdef OPENMP}
  \PYG{n}{me} \PYG{o}{=} \PYG{n}{OMP\PYGZus{}GET\PYGZus{}THREAD\PYGZus{}NUM}\PYG{p}{(}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}else}
  \PYG{n}{me} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{c+cp}{\PYGZsh{}endif}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
For Fortran coarrays, consult with the GMTB helpdesk (\sphinxhref{mailto:gmtb-help@ucar.edu}{gmtb-help@ucar.edu}).

\end{itemize}




\chapter{Scientific Documentation Rules}
\label{\detokenize{ScientificDocRules:scientific-documentation-rules}}\label{\detokenize{ScientificDocRules:scientificdocrules}}\label{\detokenize{ScientificDocRules::doc}}
Technically, scientific documentation is not needed for a parameterization
to work with the CCPP. However, scientific and technical documentation is
important for code maintenance and for fostering understanding among stakeholders
and is required of physics schemes in order to be included in the CCPP. This
section describes the process used for documenting parameterizations in the CCPP.
Doxygen was chosen as a platform for generating human-readable output due to its
built-in functionality with Fortran, its high level of configurability, and its
ability to parse in-line comments within the source code. Keeping documentation
with the source itself increases the likelihood that the documentation will be
updated along with the underlying code. Additionally, inline documentation is
amenable to version control.

The purpose of this section is to provide an understanding of how to properly
document a physics scheme using doxygen in-line comments. It covers what kind of
information should be in the documentation, how to mark up the in-line comments
so that doxygen will parse it correctly, where to put various comments within
the code, and how to configure and run doxygen to generate HTML (or other format)
output. Part of this documentation, namely subroutine argument tables, have
functional significance as part of the CCPP infrastructure. These tables must be
in a particular format to be parsed by Python scripts that “automatically” generate
a software cap for a given physics scheme. Although the procedure outlined herein
is not unique, following it will provide a level of continuity with previous
documented schemes.  Reviewing the documentation for CCPP v2.0 parameterizations
is a good way of getting started in writing documentation for a new scheme. The
CCPP Scientific Documentation can be converted to html format
(see \sphinxurl{https://dtcenter.org/gmtb/users/ccpp/docs/sci\_doc\_v2/}).


\section{Doxygen comments and commands}
\label{\detokenize{ScientificDocRules:doxygen-comments-and-commands}}
Firstly, be aware that regular Fortran comments using \sphinxcode{\sphinxupquote{“!”}} are not parsed
by Doxygen. The Doxygen in-line comment block begins with \sphinxcode{\sphinxupquote{“!\textgreater{}”}}, and
subsequent lines begin with \sphinxcode{\sphinxupquote{“!!”}}. All Doxygen commands start with a backslash
(\sphinxcode{\sphinxupquote{“\textbackslash{}”}}) or an at-sign (\sphinxcode{\sphinxupquote{“@”}}). Example in the first line of each Fortran file,
brief one sentence overview of the file purpose using Doxygen command \sphinxstylestrong{“\textbackslash{}file”}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!\PYGZgt{} \PYGZbs{}file gwdps.f}
\PYG{c}{!! This file is the  parameterization of orographic gravity wave}
\PYG{c}{!! drag and mountain blocking.}
\end{sphinxVerbatim}

The parameter definition begins with \sphinxcode{\sphinxupquote{“!\textless{}”}}, where the sign \sphinxcode{\sphinxupquote{‘\textless{}’}} just tells
Doxygen that documentation follows after the member. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{parameter}\PYG{p}{,} \PYG{k}{public} \PYG{k+kd}{::} \PYG{n}{NF\PYGZus{}VGAS} \PYG{o}{=} \PYG{l+m+mi}{10}   \PYG{c}{!\PYGZlt{} number of gas species}
\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{parameter}         \PYG{k+kd}{::} \PYG{n}{IMXCO2}  \PYG{o}{=} \PYG{l+m+mi}{24}   \PYG{c}{!\PYGZlt{} input CO2 data longitude points}
\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{parameter}         \PYG{k+kd}{::} \PYG{n}{JMXCO2}  \PYG{o}{=} \PYG{l+m+mi}{12}   \PYG{c}{!\PYGZlt{} input CO2 data latitude points}
\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{parameter}         \PYG{k+kd}{::} \PYG{n}{MINYEAR} \PYG{o}{=} \PYG{l+m+mi}{1957} \PYG{c}{!\PYGZlt{} earlist year 2D CO2 data available}
\end{sphinxVerbatim}

If you simply want Doxygen to use the original comments, you must modify the comment
line to use \sphinxcode{\sphinxupquote{“!\textgreater{}”}} at the first line and \sphinxcode{\sphinxupquote{“!!”}} at the subsequent lines.


\section{Doxygen Documentation Style}
\label{\detokenize{ScientificDocRules:doxygen-documentation-style}}
To document a physics suite, a broad array of information should be included
in order to serve both software engineering and scientific purposes. The
documentation style could be divided into four categories:
\begin{itemize}
\item {} 
Doxygen Files

\item {} 
Doxygen Pages (Overview page and scheme pages)

\item {} 
Doxygen Modules

\item {} 
Bibliography

\end{itemize}


\subsection{Doxygen files}
\label{\detokenize{ScientificDocRules:doxygen-files}}
Doxygen provides the “\textbackslash{}file” tag as a way to provide documentation on the
Fortran source code file level. That is, in the generated documentation,
one may navigate by source code filenames (if desired) rather than through
a “functional” navigation. The most important documentation organization is
through the “module” concept mentioned below, because the division of a scheme
into multiple source files is often functionally irrelevant. Nevertheless,
using a “file” tag provides an alternate path to navigate the documentation
and it should be included in every source file. Therefore, it is prudent to
include a small documentation block to describe what code is in each file
using the “\textbackslash{}file” tag, e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!\PYGZgt{} \PYGZbs{}file gwdps.f}
\PYG{c}{!! This file is the  parameterization of orographic gravity wave}
\PYG{c}{!! drag and mountain blocking.}
\end{sphinxVerbatim}

The brief description for each file is displayed next to the source filename
on the Doxygen-generated “File List” page (see \hyperref[\detokenize{ScientificDocRules:doxygen-file-list}]{Figure \ref{\detokenize{ScientificDocRules:doxygen-file-list}}}).

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{DoxygenFileList}.png}
\end{figure}


\subsection{Doxygen Overview Page}
\label{\detokenize{ScientificDocRules:doxygen-overview-page}}
Pages in Doxygen can be used for documentation that is not directly attached
to a source code entity such as file or module. They are external text files
that generate pages with a high-level scientific overview and
typically contain a longer description of a project or suite. You can refer to
any source code entity from within the page.

The GMTB maintains a main page, created by the Doxygen command
\sphinxstylestrong{“\textbackslash{}mainpage”}, containing an overall description and background of the CCPP.
Physics developers do not have to edit the file with the mainpage, which has a
user-visible title, but not label:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/**}
\PYG{g+go}{\PYGZbs{}mainpage Introduction}
\PYG{g+go}{...}
\PYG{g+go}{*/}
\end{sphinxVerbatim}

All other pages listed under the main page are created using the Doxygen
tag \sphinxstylestrong{“\textbackslash{}page”} described in the next section. In any Doxygen page,
you can refer to any entity of source code by using Doxygen tag \sphinxstylestrong{“\textbackslash{}ref”}
or \sphinxstylestrong{“@ref”}. Example in \sphinxcode{\sphinxupquote{code\_overview.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{The FV3GFS physics suite uses the parameterizations in the following order,}
\PYG{g+go}{as defined in  \PYGZbs{}c suite\PYGZus{}SCM\PYGZus{}GFS\PYGZus{}2017\PYGZus{}updated.xml and \PYGZbs{}c suite\PYGZus{}SCM\PYGZus{}GFS\PYGZus{}2018\PYGZus{}updated.xml:}
\PYG{g+go}{ + @ref GFS\PYGZus{}RRTMG}
\PYG{g+go}{ + @ref GFS\PYGZus{}SFCLYR}
\PYG{g+go}{ + @ref GFS\PYGZus{}NSST}
\PYG{g+go}{ + @ref GFS\PYGZus{}NOAH}
\PYG{g+go}{ + @ref GFS\PYGZus{}SFCSICE}
\PYG{g+go}{ + @ref GFS\PYGZus{}HEDMF}
\PYG{g+go}{ + @ref GFS\PYGZus{}GWDPS}
\PYG{g+go}{ + @ref GFS\PYGZus{}RAYLEIGH}
\PYG{g+go}{ + @ref GFS\PYGZus{}OZPHYS}
\PYG{g+go}{ + @ref GFS\PYGZus{}H2OPHYS}
\PYG{g+go}{ + @ref GFS\PYGZus{}SAMFdeep}
\PYG{g+go}{ + @ref GFS\PYGZus{}GWDC}
\PYG{g+go}{ + @ref GFS\PYGZus{}SAMFshal}
\PYG{g+go}{ + GFS Microphysics (MP) scheme option:}
\PYG{g+go}{   + @ref GFDL\PYGZus{}cloud}
\PYG{g+go}{      + @ref gfdlmp}
\PYG{g+go}{      + @ref fast\PYGZus{}sat\PYGZus{}adj}
\PYG{g+go}{   + @ref GFS\PYGZus{}ZHAOC}
\PYG{g+go}{      + @ref condense}
\PYG{g+go}{      + @ref precip}
\PYG{g+go}{ + @ref GFS\PYGZus{}CALPRECIPTYPE}
\end{sphinxVerbatim}

The HTML result is \sphinxhref{https://dtcenter.org/gmtb/users/ccpp/docs/sci\_doc\_v2/subpage\_overview.html}{here}.
You can see that the \sphinxstylestrong{“+”} signs before \sphinxstylestrong{“@ref”} generate a list with bullets.
Doxygen command \sphinxstylestrong{“\textbackslash{}c”} displays its argument using a typewriter font.


\subsection{Physics Scheme Pages}
\label{\detokenize{ScientificDocRules:physics-scheme-pages}}
Each major scheme in CCPP should have its own scheme page containing an
overview of the parameterization.  This page is not tied to the Fortran
code directly; instead, it is created with a separate text file that starts
with the command \sphinxstylestrong{“\textbackslash{}page”}.  Each page has a label (e.g., “GFS\_ZHAOC” in
the following example) and a user-visible title (“GFS Zhao-Carr Microphysics
Scheme” in the following example). It is noted that labels must be unique
across the entire Doxygen project so that the \sphinxstylestrong{“\textbackslash{}ref”} command can be used
to create an unambiguous link to the structuring element. It therefore makes
sense to choose label names that refer to their context.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/**}
\PYG{g+go}{\PYGZbs{}page GFS\PYGZus{}ZHAOC GFS Zhao\PYGZhy{}Carr Microphysics Scheme}

\PYG{g+go}{\PYGZbs{}section des\PYGZus{}zhao Description}
\PYG{g+go}{This is the GFS scheme for grid\PYGZhy{}scale condensation and precipitation which is}
\PYG{g+go}{based on Zhao and Carr (1997) \PYGZbs{}cite zhao\PYGZus{}and\PYGZus{}carr\PYGZus{}1997 and Sundqvist et al.}
\PYG{g+go}{(1989) \PYGZbs{}cite sundqvist\PYGZus{}et\PYGZus{}al\PYGZus{}1989 .}
\PYG{g+go}{...}
\PYG{g+go}{Figure 1 shows a schematic illustration of this scheme.}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZbs{}image  html  GFS\PYGZus{}zhaocarr\PYGZus{}schematic.png \PYGZdq{}Figure 1: Schematic illustration of the precipitation scheme\PYGZdq{} width=10cm}
\PYG{g+go}{…}

\PYG{g+go}{\PYGZbs{}section intro\PYGZus{}zhao Intraphysics Communication}
\PYG{g+go}{ + For grid\PYGZhy{}scale condensation and evaporation of cloud process}
\PYG{g+go}{(\PYGZbs{}ref arg\PYGZus{}table\PYGZus{}zhaocarr\PYGZus{}gscond\PYGZus{}run)}
\PYG{g+go}{+ For precipitation (snow or rain) production}
\PYG{g+go}{(\PYGZbs{}ref arg\PYGZus{}table\PYGZus{}zhaocarr\PYGZus{}precpd\PYGZus{}run)}

\PYG{g+go}{\PYGZbs{}section Gen\PYGZus{}zhao  General Algorithm}
\PYG{g+go}{ + \PYGZbs{}ref general\PYGZus{}gscond}
\PYG{g+go}{ + \PYGZbs{}ref general\PYGZus{}precpd}

\PYG{g+go}{*/}
\end{sphinxVerbatim}

The HTML result is \sphinxhref{https://dtcenter.org/gmtb/users/ccpp/docs/sci\_doc\_v2/GFS\_ZHAOC.html}{here}.
The physics scheme page will often describe the following:
\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{Description section (\sphinxstylestrong{“\textbackslash{}section”}), which usually includes:}] \leavevmode\begin{itemize}
\item {} 
Scientific origin and scheme history (\sphinxstylestrong{“\textbackslash{}cite”})

\item {} 
Key features and differentiating points

\item {} 
A picture is sometimes worth a thousand words (\sphinxstylestrong{“\textbackslash{}image”})

To insert images into Doxygen documentation, you’ll need to have your
images ready in a graphical format (i.e., .png) depending
on which Doxygen output you’re willing to generate. For example, for LaTeX
output the images must be provided in Encapsulated PostScript (.eps); For
HTML output the images could be provided in the Portable Network Graphic
(.png) format. Example of including the same image in multiple formats for
HTML and LaTeX outputs:

\end{itemize}

\end{description}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZbs{}image  html  gfdl\PYGZus{}cloud\PYGZus{}mp\PYGZus{}diagram.png \PYGZdq{}Figure 1: GFDL MP at a glance (Courtesy of S.J. Lin at GFDL)\PYGZdq{} width=10cm}
\PYG{g+go}{\PYGZbs{}image  latex  gfdl\PYGZus{}cloud\PYGZus{}mp\PYGZus{}diagram.eps \PYGZdq{}Figure 1: GFDL MP at a glance (Courtesy of S.J. Lin at GFDL)\PYGZdq{} width=10cm}
\end{sphinxVerbatim}

In the CCPP, images are put under \sphinxcode{\sphinxupquote{./docs/img/}} directory.
\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
Intraphysics Communication Section (\sphinxstylestrong{“\textbackslash{}section”})
\begin{itemize}
\item {} 
The argument table for CCPP entry point subroutine \sphinxstylestrong{\{scheme\}\_run} will be in this section.
It is created by inserting a reference link (\sphinxstylestrong{“\textbackslash{}ref”}) to the table in the Fortran code
for the scheme.

\end{itemize}

\item {} 
General Algorithm Section (\sphinxstylestrong{“\textbackslash{}section”})
\begin{itemize}
\item {} 
The general description of the algorithn will be in this section.  It is created by inserting
a reference link (\sphinxstylestrong{“\textbackslash{}ref”}) in the Fortran code for the scheme.

\end{itemize}

\end{enumerate}

The symbols \sphinxstylestrong{“/**”} and \sphinxstylestrong{“*/”} need to be the first and last entries of the page.
Here is an example of GFS Zhao-Carr microphysics scheme page:

Note that separate pages can also be created to document something that is not a scheme.
For example, a page could be created to describe a suite, or how a set of schemes work
together.  Doxygen automatically generates an index of all pages that is visible at the
top-level of the documentation, thus allowing the user to quickly find, and navigate
between, the available pages.


\subsection{Doxygen Modules}
\label{\detokenize{ScientificDocRules:doxygen-modules}}
The CCPP documentation is based on Doxygen modules (note this is not the same as
Fortran modules). Each Doxygen module pertains to a particular parameterization and
is used to aggregate all code related to that scheme, even when it is in separate
files. Since Doxygen cannot know which files or subroutines belong to each physics
scheme, each relevant subroutine must be tagged with the module name. This allows
Doxygen to understand your modularized design and generate the documentation accordingly.
\sphinxhref{https://dtcenter.org/gmtb/users/ccpp/docs/sci\_doc\_v2/modules.html}{Here}
is a list of module list defined in CCPP.

A module is defined using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{!\PYGZgt{}\PYGZbs{}defgroup group\PYGZus{}name group\PYGZus{}title}
\end{sphinxVerbatim}

Where \sphinxcode{\sphinxupquote{group\_name}} is the identifier and the \sphinxcode{\sphinxupquote{group\_title}} is what the
group is referred to in the output. In the example below, we’re defining a parent
module “GFS radsw Main”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!\PYGZgt{} \PYGZbs{}defgroup module\PYGZus{}radsw\PYGZus{}main GFS radsw Main}
\PYG{c}{!! This module includes NCEP\PYGZsq{}s modifications of the RRTMG\PYGZhy{}SW radiation}
\PYG{c}{!! code from AER.}
\PYG{c}{!! ...}
\PYG{c}{!!\PYGZbs{}author   Eli J. Mlawer, emlawer@aer.com}
\PYG{c}{!!\PYGZbs{}author   Jennifer S. Delamere, jdelamer@aer.com}
\PYG{c}{!!\PYGZbs{}author   Michael J. Iacono, miacono@aer.com}
\PYG{c}{!!\PYGZbs{}author   Shepard A. Clough}
\PYG{c}{!!\PYGZbs{}version NCEP SW v5.1  Nov 2012 \PYGZhy{}RRTMG\PYGZhy{}SW v3.8}
\PYG{c}{!!}
\end{sphinxVerbatim}

One or more contact persons should be listed with author. If you make
significant modifications or additions to a file , consider adding an
author and a version line for yourself. The above example generates
the Author, Version sections on the page. All email addresses are converted
to mailto hypertext links automatically:
\begin{description}
\item[{\sphinxstylestrong{Author}}] \leavevmode
Eli J. Mlawer, \sphinxhref{mailto:emlawer@aer.com}{emlawer@aer.com}

Jennifer S. Delamere, \sphinxhref{mailto:jdelamer@aer.com}{jdelamer@aer.com}

Michael J. Iacono, \sphinxhref{mailto:miacono@aer.com}{miacono@aer.com}

Shepard A. Clough

\item[{\sphinxstylestrong{Version}}] \leavevmode
NCEP SW v5.1  Nov 2012 -RRTMG-SW v3.8

\end{description}

In order to include other pieces of code in the same module, the following
tag must be used at the beginning of a comment block:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZbs{}ingroup group\PYGZus{}name}
\end{sphinxVerbatim}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!\PYGZgt{}\PYGZbs{}ingroup module\PYGZus{}radsw\PYGZus{}main}
\PYG{c}{!\PYGZgt{} The subroutine computes the optical depth in band 16:  2600\PYGZhy{}3250}
\PYG{c}{!! cm\PYGZhy{}1 (low \PYGZhy{} h2o,ch4; high \PYGZhy{} ch4)}
\PYG{c}{!\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
      \PYG{k}{subroutine }\PYG{n}{taumol16}
\PYG{c}{!...................................}
\end{sphinxVerbatim}

In the same comment block where a group is defined for a physics scheme,
there should be some additional documentation. First, using the “brief”
command, a brief one or two sentence description of the scheme should be
included. After a blank doxygen comment line, begin the scheme origin
and history using “version”, “author” and “date”.

Each subroutine that is a CCPP entry point to a parameterization, should
be further documented with a documentation block immediately preceding
its definition in the source. The documentation block should include at
least the following components:
\begin{itemize}
\item {} 
A brief one- or two-sentence description with the brief tag

\item {} 
A more detailed one or two paragraph description of the function of the subroutine

\item {} \begin{description}
\item[{An argument table that includes entries for each subroutine argument}] \leavevmode\begin{itemize}
\item {} 
The argument table content should be immediately preceded by the following line:

\end{itemize}

\end{description}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!!\PYGZbs{}section arg\PYGZus{}table\PYGZus{}SUBROUTINE\PYGZus{}NAME}
\end{sphinxVerbatim}

This line is also functional documentation used during the CCPP prebuild step.  The
first line of the table should contain the following “header” names
\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{local\_name}: contains the local subroutine variable name

\item {} 
\sphinxstylestrong{standard\_name}: CF-compliant standard name

\item {} 
\sphinxstylestrong{long\_name}: a short description

\item {} 
\sphinxstylestrong{units}: format follows “unit exponent”, i.e. m2 s-2 for m2/s2

\item {} 
\sphinxstylestrong{rank}: 0 for scalar, 1 for 1-D array, 2 for 2-D array, etc.

\item {} 
\sphinxstylestrong{type}: integer, real, logical, etc.

\item {} 
\sphinxstylestrong{kind}: the specified floating point precision kind (at present, to be
extended to different integer kinds in the future)

\item {} 
\sphinxstylestrong{intent}: in, out, inout

\item {} 
\sphinxstylestrong{optional}: T/F

\end{enumerate}

The argument table should be immediately followed by a blank doxygen line “!!”,
which is needed to denote the end of an argument table. Here is an example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!! \PYGZbs{}section arg\PYGZus{}table\PYGZus{}scheme\PYGZus{}X\PYGZus{}\PYGZus{}run Argument Table}
\PYG{c}{!! \textbar{} local\PYGZus{}name \textbar{} standard\PYGZus{}name                            \textbar{} long\PYGZus{}name                                   \textbar{} units   \textbar{} rank \textbar{} type    \textbar{}    kind   \textbar{} intent \textbar{} optional \textbar{}}
\PYG{c}{!! \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}}
\PYG{c}{!! \textbar{} im         \textbar{} horizontal\PYGZus{}loop\PYGZus{}extent                   \textbar{} horizontal loop extent                      \textbar{} count   \textbar{}    0 \textbar{} integer \textbar{}           \textbar{} in     \textbar{} F        \textbar{}}
\PYG{c}{!! \textbar{} levs       \textbar{} vertical\PYGZus{}dimension                       \textbar{} vertical layer dimension                    \textbar{} count   \textbar{}    0 \textbar{} integer \textbar{}           \textbar{} in     \textbar{} F        \textbar{}}
\PYG{c}{!! \textbar{} vdftra     \textbar{} vertically\PYGZus{}diffused\PYGZus{}tracer\PYGZus{}concentration \textbar{} tracer concentration diffused by PBL scheme \textbar{} kg kg\PYGZhy{}1 \textbar{}    3 \textbar{} real    \textbar{} kind\PYGZus{}phys \textbar{} inout  \textbar{} F        \textbar{}}
\end{sphinxVerbatim}

The order of arguments in the table does not have to match the order of actual
arguments in the subroutine, but it is preferred.
\begin{itemize}
\item {} 
A section called “General Algorithm” with a bullet or numbered list of
the tasks completed in the subroutine algorithm

\item {} 
At the end of initial subroutine documentation block, a “Detailed algorithm”
section is started and the entirety of the code  is encompassed with the
“!\textgreater{} @\{” and “!\textgreater{} @\}” delimiters. This way, any comments explaining detailed
aspects of the code are automatically included in the “Detailed Algorithm” section.

\end{itemize}

For subroutines that are not a CCPP entry point to a scheme, no argument table
is required. But it is suggested that following “ingroup” and “brief”, use
“param” to define each argument with local name, a short description and unit, i.e.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{!\PYGZgt{}  \PYGZbs{}ingroup HEDMF}
\PYG{g+go}{!!  \PYGZbs{}brief This subroutine is used for calculating the mass flux and updraft properties.}
\PYG{g+go}{!!  ...}
\PYG{g+go}{!!}
\PYG{g+go}{!!  \PYGZbs{}param[in] im      integer, number of used points}
\PYG{g+go}{!!  \PYGZbs{}param[in] ix      integer, horizontal dimension}
\PYG{g+go}{!!  \PYGZbs{}param[in] km      integer, vertical layer dimension}
\PYG{g+go}{!!  \PYGZbs{}param[in] ntrac   integer, number of tracers}
\PYG{g+go}{!!  \PYGZbs{}param[in] delt    real, physics time step}
\PYG{g+go}{!!  ...}
\PYG{g+go}{!!  \PYGZbs{}section general\PYGZus{}mfpbl mfpbl General Algorithm}
\PYG{g+go}{!!  \PYGZhy{}\PYGZsh{} Determine an updraft parcel\PYGZsq{}s entrainment rate, buoyancy, and vertical velocity.}
\PYG{g+go}{!!  \PYGZhy{}\PYGZsh{} Recalculate the PBL height ...}
\PYG{g+go}{!!  \PYGZhy{}\PYGZsh{} Calculate the mass flux profile and updraft properties.}
\PYG{g+go}{!!  \PYGZbs{}section detailed\PYGZus{}mfpbl mfpbl Detailed Algorithm}
\PYG{g+go}{!\PYGZgt{}  @\PYGZob{}}
\PYG{g+go}{       subroutine mfpbl(im,ix,km,ntrac,delt,cnvflg,                       \PYGZam{}}
\PYG{g+go}{       \PYGZam{}   zl,zm,thvx,q1,t1,u1,v1,hpbl,kpbl,                              \PYGZam{}}
\PYG{g+go}{       \PYGZam{}   sflx,ustar,wstar,xmf,tcko,qcko,ucko,vcko)}
\PYG{g+go}{         …}
\PYG{g+go}{       end subroutine mfpbl}
\PYG{g+go}{!\PYGZgt{}  @\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Bibliography}
\label{\detokenize{ScientificDocRules:bibliography}}
Doxygen can handle in-line paper citations and link to an automatically created
bibliography page. The bibliographic data for any papers that are cited need to
be put in BibTeX format and Saved in a .bib file. The bib file for CCPP is
included in the repository, and the Doxygen configuration option
\sphinxcode{\sphinxupquote{cite\_bib\_files}} points to the included file.

Citations are invoked with the following tag:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZbs{}cite bibtex\PYGZus{}key\PYGZus{}to\PYGZus{}paper}
\end{sphinxVerbatim}


\subsection{Equations}
\label{\detokenize{ScientificDocRules:equations}}
See \sphinxhref{http://www.doxygen.nl/manual/formulas.html}{link} for information
about including equations. For the best rendering, the following option
should be set in the Doxygen configuration file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{USE\PYGZus{}MATHJAX            = YES}
\PYG{g+go}{MATHJAX\PYGZus{}RELPATH        =  https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2}
\end{sphinxVerbatim}

There are many great online resources to use the LaTeX math typesetting used in Doxygen.


\section{Doxygen Configuration}
\label{\detokenize{ScientificDocRules:doxygen-configuration}}

\subsection{Configuration file}
\label{\detokenize{ScientificDocRules:configuration-file}}
The CCPP contains a Doxygen configuration file
\sphinxcode{\sphinxupquote{./ccpp/physics/physics/docs/ccpplatex\_dox}}, such that you don’t need to
create an additional one.

If starting from scratch, you can generate a default configuration file using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{doxygen \PYGZhy{}g \PYGZlt{}config\PYGZus{}file\PYGZgt{}}
\end{sphinxVerbatim}

Then you can edit the default configuration file to serve your needs. The default
file includes plenty of comments to explain all the options. Some of the important
things you need to pay attention to are:
\begin{itemize}
\item {} 
The name of your project:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{PROJECT\PYGZus{}NAME = ‘your project name’}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The input files (relative to the directory where you run Doxygen):

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{INPUT =}
\end{sphinxVerbatim}

The following lines should be listed here: the Doxygen mainpage text file, the
scheme pages, and the source codes to be contained in the output. The order in
which schemes are listed determines the order in the html result.
\begin{itemize}
\item {} 
The directory where to put the documentation (if you leave it empty, then the
documentation will be created in the directory where you run Doxygen):

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{OUTPUT\PYGZus{}DIRECTORY = doc}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The type of documentation you want to generate (HTML, LaTeX and/or something else):

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{GENERATE\PYGZus{}HTML = YES}
\end{sphinxVerbatim}

If HTML is chosen, the following tells doxygen where to put the html documentation
relative OUTPUT\_DIRECTORY:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{HTML\PYGZus{}OUTPUT = html}
\PYG{g+go}{HTML\PYGZus{}FILE\PYGZus{}EXTENSION = .html}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{HTML\_FILE\_EXTENSION}} tells what the extension of the html files should be.
\begin{itemize}
\item {} 
Other important settings for a Fortran code project are:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{OPTIMIZE\PYGZus{}FOR\PYGZus{}FORTRAN        =    YES}
\PYG{g+go}{EXTENSION\PYGZus{}MAPPING           = .f=FortranFree        \PYGZbs{}}
\PYG{g+go}{                              .F90=FortranFree      \PYGZbs{}}
\PYG{g+go}{                              .f90=FortranFree}
\PYG{g+go}{LAYOUT\PYGZus{}FILE                 = ccpp\PYGZus{}dox\PYGZus{}layout.xml}
\PYG{g+go}{CITE\PYGZus{}BIB\PYGZus{}FILES              = library.bib}
\PYG{g+go}{FILE\PYGZus{}PATTERN                = *.f     \PYGZbs{}}
\PYG{g+go}{                              *.F90   \PYGZbs{}}
\PYG{g+go}{                              *.f90   \PYGZbs{}}
\PYG{g+go}{                              *.txt}
\PYG{g+go}{GENERATE\PYGZus{}TREEVIEW           = yes}
\end{sphinxVerbatim}

Doxygen files for layout (ccpp\_dox\_layout.xml), a html style (ccpp\_dox\_extra\_style.css),
and bibliography (library.bib) are provided with the CCPP. Additionally, a
configuration file is supplied, with the following variables modified from the default:


\subsection{Diagrams}
\label{\detokenize{ScientificDocRules:diagrams}}
On its own, Doxygen is capable of creating simple text-based class diagrams.
With the help of the additional software GraphViz, Doxygen can generate
additional graphics-based diagrams, optionally in UML style. To enable
GraphViz support, the configure file parameter “HAVE\_DOT” must be set to “YES”.

You can use Doxygen to create call graphs of all the physics schemes in CCPP.
In order to create the call graphs you will need to set the following options in
your Doxygen config file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{HAVE\PYGZus{}DOT             = YES}
\PYG{g+go}{EXTRACT\PYGZus{}ALL          = YES}
\PYG{g+go}{EXTRACT\PYGZus{}PRIVATE      = YES}
\PYG{g+go}{EXTRACT\PYGZus{}STATIC       = YES}
\PYG{g+go}{CALL\PYGZus{}GRAPH           = YES}
\end{sphinxVerbatim}

Note that will need the DOT (graph description language) utility to be installed
when starting Doxygen. Doxygen will call it to generate the graphs. On most
distributions the DOT utility can be found in the GraphViz package. Here is
the call graph for subroutine mpdrv in GFDL cloud microphysics generated by Doxygen:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{DoxygenCallGraph}.png}
\end{figure}


\section{Using Doxygen}
\label{\detokenize{ScientificDocRules:using-doxygen}}
In order to generate Doxygen-based documentation, you need to follow four steps:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Have the Doxygen executable installed on your computer. This is already done on
theia machine. Add the following line into .cshrc file under your home directory:

\sphinxcode{\sphinxupquote{alias doxygen/scratch4/BMC/gmtb/doxygen-1.8.10/bin/doxygen}}

\end{enumerate}

Source your .cshrc file.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
Document your code, including Doxygen main page, scheme pages and in-line
comments within source code as described above.

\item {} 
Prepare a Bibliography file in BibTex format for paper referred in the physics suite.

\item {} 
create or edit a Doxygen configuration file to control what Doxygen pages, source
files and bibliography file get parsed, how the source files get parsed, and to
customize the output.

\item {} 
Run the Doxygen command from the command line with the doxygen configuration file
given as an argument:

\end{enumerate}
\begin{quote}

\sphinxcode{\sphinxupquote{\$doxygen \$PATH\_TO\_CONFIG\_FILE/\textless{}config\_file\textgreater{}}}
\end{quote}

Running this command may output compiler-like warning or errors that need to be fixed
in order to produce proper output. Output is generated depending on the type specified
(HTML, LaTeX, etc.) in the configuration file and is put in a location specified in the
configuration file. The generated HTML documentation can be viewed by pointing a HTML
browser to the \sphinxcode{\sphinxupquote{index.html}} file in the \sphinxcode{\sphinxupquote{./docs/doc/html/}} directory.

For precise instructions on creating the scientific documentation, contact the GMTB
helpdesk at \sphinxhref{mailto:gmtb-help@ucar.edu}{gmtb-help@ucar.edu}.


\chapter{Configuring and Building Options (Weiwei)}
\label{\detokenize{ConfigBuildOptions:configuring-and-building-options-weiwei}}\label{\detokenize{ConfigBuildOptions:configbuildoptions}}\label{\detokenize{ConfigBuildOptions::doc}}

\chapter{Building and Running Host Models (Weiwei)}
\label{\detokenize{BuildingRunningHostModels:building-and-running-host-models-weiwei}}\label{\detokenize{BuildingRunningHostModels:buildingrunninghostmodels}}\label{\detokenize{BuildingRunningHostModels::doc}}

\chapter{Adding a new scheme (Weiwei)}
\label{\detokenize{AddingNewSchemes:adding-a-new-scheme-weiwei}}\label{\detokenize{AddingNewSchemes:addnewschemes}}\label{\detokenize{AddingNewSchemes::doc}}

\chapter{Glossary}
\label{\detokenize{Glossary:glossary}}\label{\detokenize{Glossary::doc}}\begin{description}
\item[{CCPP\index{CCPP@\spxentry{CCPP}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-ccpp}}}] \leavevmode
the Common Community Physics Package designed to facilitate the implementation of
physics innovations in state-of-the-art atmospheric models

\item[{CCPP framework\index{CCPP framework@\spxentry{CCPP framework}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-ccpp-framework}}}] \leavevmode
the driver that connects the physics schemes with a host model

\item[{CCPP physics\index{CCPP physics@\spxentry{CCPP physics}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-ccpp-physics}}}] \leavevmode
the pool of CCPP-compliant physics schemes

\item[{dynamic CCPP build\index{dynamic CCPP build@\spxentry{dynamic CCPP build}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-dynamic-ccpp-build}}}] \leavevmode
CCPP framework and physics libraries are dynamically linked to the executable

\item[{entry/exit point subroutine\index{entry/exit point subroutine@\spxentry{entry/exit point subroutine}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-entry-exit-point-subroutine}}}] \leavevmode
a subroutine that is exposed to the CCPP framework and serves as a public interface for the
underlying code; for example, scheme A uses several source files and subroutines to parameterize
a physical process, but its interaction with a host model (exchange of arguments) is entirely
through one subroutine, which is defined as the entry/exit point subroutine

\item[{group\index{group@\spxentry{group}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-group}}}] \leavevmode
Set of physics schemes within a suite definition file (SDF) that are called together, for example ‘radiation’

\item[{host cap\index{host cap@\spxentry{host cap}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-host-cap}}}] \leavevmode
manually-generated interface (that includes some auto-generated code) between the host
model/application and the CCPP framework and physics

\item[{host model/application\index{host model/application@\spxentry{host model/application}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-host-model-application}}}] \leavevmode
an atmospheric driver or other model that allocates memory, provides metadata for the
variables passed into and out of the physics, and controls time-stepping; the framework
that the physics schemes are connected with

\item[{hybrid CCPP\index{hybrid CCPP@\spxentry{hybrid CCPP}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-hybrid-ccpp}}}] \leavevmode
enables use of non-CCPP physics and CCPP-compliant physics in the same run

\item[{interstitial scheme\index{interstitial scheme@\spxentry{interstitial scheme}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-interstitial-scheme}}}] \leavevmode
a scheme used to calculate the missing variables based on existing variables in the model
and run before/after the scheme and cannot be part of the scheme itself. At present,
adding interstitial schemes should be done in cooperation with the GMTB Help Desk

\item[{parameterization\index{parameterization@\spxentry{parameterization}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-parameterization}}}] \leavevmode
the representation, in a dynamic model, of physical effects in terms of admittedly
oversimplified parameters, rather than realistically requiring such effects to be
consequences of the dynamics of the system (AMS Glossary)

\item[{physics cap\index{physics cap@\spxentry{physics cap}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-physics-cap}}}] \leavevmode
auto-generated interface between an individual  physics scheme and the CCPP framework

\item[{set\index{set@\spxentry{set}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-set}}}] \leavevmode
Collection of physics schemes that do not share memory (e.g. fast and slow physics)

\item[{standalone CCPP\index{standalone CCPP@\spxentry{standalone CCPP}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-standalone-ccpp}}}] \leavevmode
non-Hybrid CCPP. Only CCPP-compliant parameterizations can be used. Physics scheme
selection and order is determined by an external suite definition file (SDF)

\item[{standard\_name\index{standard\_name@\spxentry{standard\_name}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-standard-name}}}] \leavevmode
variable names based on CF conventions (\sphinxurl{http://cfconventions.org}) that are uniquely
identified by CCPP physics schemes and provided by a host model

\item[{static CCPP build\index{static CCPP build@\spxentry{static CCPP build}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-static-ccpp-build}}}] \leavevmode
CCPP framework and physics libraries are statistically linked to the executable

\item[{subcycling\index{subcycling@\spxentry{subcycling}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-subcycling}}}] \leavevmode
executing a physics scheme in a loop with a shorter timestep than the rest of physics (or the dynamics)

\item[{suite\index{suite@\spxentry{suite}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-suite}}}] \leavevmode
a collection of physics schemes and interstitial schemes that is known to work well together

\item[{suite definition file (SDF)\index{suite definition file (SDF)@\spxentry{suite definition file}\spxextra{SDF}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-suite-definition-file-sdf}}}] \leavevmode
an external file containing information about a physics suite’s construction; its contents
describe the schemes that are called, what order they are called, whether they are subcycled,
and whether they are grouped into units to be called together with intervening non-physics code

\item[{.xsd file extension\index{.xsd file extension@\spxentry{.xsd file extension}|spxpagem}\phantomsection\label{\detokenize{Glossary:term-xsd-file-extension}}}] \leavevmode
XML schema definition

\end{description}

\begin{sphinxthebibliography}{HBCF18}
\bibitem[HBCF18]{CompliantPhysicsParams:heinzelleretal2018}
D. Heinzeller, L. Bernardet, L. Carson, and G. Firl. Common community physics package (ccpp) developers’ guide v2.0. 2018. URL: \sphinxurl{https://dtcenter.org/gmtb/users/ccpp/docs/CCPP-DevGuide-v2.pdf}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}